#ifndef corelox_vm_h
#define corelox_vm_h

#include "chunk.h"
#include "object.h"
#include "table.h"
#include "value.h"

/**
 * @file vm.h
 * @brief Virtual machine implementation for executing bytecode.
 *
 * This header defines the virtual machine (VM) that executes bytecode
 * generated by the compiler. It includes the structure for maintaining
 * the execution state (like the instruction pointer and the stack)
 * and provides the main execution loop, memory management, and stack operations.
 */

#define FRAMES_MAX 64
#define STACK_MAX (FRAMES_MAX * UINT8_COUNT)

/**
 * @brief Represents a call frame in the virtual machine.
 *
 * The `CallFrame` struct represents a call frame in the virtual machine.
 * It holds information about the current function being executed, the
 * instruction pointer, and the slots used for local variables and arguments.
 */
typedef struct {
  ObjClosure* closure;  ///< The closure object for the current function.
  uint8_t* ip;          ///< The instruction pointer for the current frame.
  Value* slots;         ///< Array of slots for local variables and arguments.
} CallFrame;

/**
 * @brief Represents the virtual machine's execution state.
 *
 * The `VM` struct holds the state of the virtual machine, including the
 * current chunk of bytecode being executed, the instruction pointer,
 * the value stack, and the stack's current capacity.
 *
 * @tparam frames Array of call frames for function calls.
 * @tparam frameCount The number of active call frames.
 * @tparam stack Dynamic array used for the value stack.
 * @tparam stackTop Points to the top of the stack.
 * @tparam stackCapacity The current allocated capacity of the stack.
 * @tparam globals Table of global variables.
 * @tparam strings Table of interned string objects.
 * @tparam initString The string "init" used for class initialization.
 * @tparam openUpvalues Linked list of open upvalues for closure capture.
 * @tparam bytesAllocated Total number of bytes allocated by the VM. Used for GC.
 * @tparam nextGC Threshold for the next garbage collection cycle.
 * @tparam objects Linked list of all objects managed by the VM.
 * @tparam grayCount Number of gray objects in the object list
 * @tparam grayCapacity Number of gray objects in the stack
 */
typedef struct {
  CallFrame frames[FRAMES_MAX];  ///< Array of call frames for function calls.
  int frameCount;                ///< The number of active call frames.

  Value* stack;       ///< Dynamic array used for the value stack.
  Value* stackTop;    ///< Points to the top of the stack.
  int stackCapacity;  ///< The current allocated capacity of the stack.

  Table globals;  ///< Table of global variables.

  Table strings;          ///< Table of interned string objects.
  ObjString* initString;  ///< The string "init" used for class initialization.

  ObjUpvalue* openUpvalues;  ///< Linked list of open upvalues for closure capture.

  size_t bytesAllocated;  ///< Total number of bytes allocated by the VM. Used for GC.
  size_t nextGC;          ///< Threshold for the next garbage collection cycle.
  Obj* objects;           ///< Linked list of all objects managed by the VM.
  int grayCount;          ///< Number of gray objects in the object list
  int grayCapacity;       ///< Number of gray objects in the stack
  Obj** grayStack;        ///< Stack of objects with marked roots to traverse during GC loop
} VM;

/**
 * @brief Result codes for the virtual machine's interpretation.
 *
 * These enum values represent the possible outcomes of interpreting
 * a chunk of bytecode, including successful execution, compilation
 * errors, and runtime errors.
 */
typedef enum {
  INTERPRET_OK,             ///< Interpretation completed successfully.
  INTERPRET_COMPILE_ERROR,  ///< A compilation error occurred before execution.
  INTERPRET_RUNTIME_ERROR   ///< A runtime error occurred during execution.
} InterpretResult;

/**
 * @brief Global static instance of the virtual machine.
 *
 * The `vm` variable is a global static instance of the virtual machine
 * that is used throughout the interpreter to execute bytecode and manage
 * the VM's state. It is defined in `vm.c` and initialized in `main.c`.
 */
extern VM vm;

/**
 * @brief Initializes the virtual machine.
 *
 * This function sets up the virtual machine's internal state, preparing it
 * for bytecode execution. It initializes the stack and other execution-related
 * structures, and must be called before any bytecode is executed.
 */
void initVM();

/**
 * @brief Frees the virtual machine's memory.
 *
 * This function deallocates memory used by the virtual machine, including
 * its stack and other execution-related structures. It should be called
 * when the virtual machine is no longer needed.
 */
void freeVM();

/**
 * @brief Interprets and executes a chunk of bytecode from source code.
 *
 * This function compiles the provided source code into bytecode and
 * then executes that bytecode in the virtual machine. It returns an
 * `InterpretResult` indicating whether the execution was successful
 * or if there were errors during compilation or runtime.
 *
 * @param source The source code to compile and execute.
 * @return An `InterpretResult` representing the outcome of the execution.
 */
InterpretResult interpret(const char* source);

/**
 * @brief Pushes a value onto the virtual machine's stack.
 *
 * This function pushes a `Value` onto the top of the stack, advancing
 * the `stackTop` pointer. If the stack exceeds its current capacity,
 * it dynamically grows to accommodate more values.
 *
 * @param value The value to push onto the stack.
 */
void push(Value value);

/**
 * @brief Pops a value off the virtual machine's stack.
 *
 * This function removes and returns the value from the top of the stack,
 * decrementing the `stackTop` pointer. The value is removed from the stack,
 * allowing space for new values to be pushed later.
 *
 * @return The value popped from the top of the stack.
 */
Value pop();

#endif