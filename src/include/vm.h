#ifndef corelox_vm_h
#define corelox_vm_h

#include "chunk.h"
#include "table.h"
#include "value.h"

/**
 * @file vm.h
 * @brief Virtual machine implementation for executing bytecode.
 *
 * This header defines the virtual machine (VM) that executes bytecode
 * generated by the compiler. It includes the structure for maintaining
 * the execution state (like the instruction pointer and the stack)
 * and provides the main execution loop, memory management, and stack operations.
 */

#define STACK_MAX 256  ///< Initial maximum size of the stack.

/**
 * @brief Represents the virtual machine's execution state.
 *
 * The `VM` struct holds the state of the virtual machine, including the
 * current chunk of bytecode being executed, the instruction pointer,
 * the value stack, and the stack's current capacity.
 */
typedef struct {
  Chunk* chunk;       ///< Pointer to the chunk of bytecode being executed.
  uint8_t* ip;        ///< Instruction pointer (points to the next bytecode to execute).
  Value* stack;       ///< Dynamic array used for the value stack.
  Value* stackTop;    ///< Points to the top of the stack.
  Table globals;      ///< Table of global variables.
  Table strings;      ///< Table of interned string objects.
  int stackCapacity;  ///< The current allocated capacity of the stack.
  Obj* objects;       ///< Linked list of all objects managed by the VM.
} VM;

/**
 * @brief Result codes for the virtual machine's interpretation.
 *
 * These enum values represent the possible outcomes of interpreting
 * a chunk of bytecode, including successful execution, compilation
 * errors, and runtime errors.
 */
typedef enum {
  INTERPRET_OK,             ///< Interpretation completed successfully.
  INTERPRET_COMPILE_ERROR,  ///< A compilation error occurred before execution.
  INTERPRET_RUNTIME_ERROR   ///< A runtime error occurred during execution.
} InterpretResult;

/**
 * @brief Global static instance of the virtual machine.
 *
 * The `vm` variable is a global static instance of the virtual machine
 * that is used throughout the interpreter to execute bytecode and manage
 * the VM's state. It is defined in `vm.c` and initialized in `main.c`.
 */
extern VM vm;

/**
 * @brief Initializes the virtual machine.
 *
 * This function sets up the virtual machine's internal state, preparing it
 * for bytecode execution. It initializes the stack and other execution-related
 * structures, and must be called before any bytecode is executed.
 */
void initVM();

/**
 * @brief Frees the virtual machine's memory.
 *
 * This function deallocates memory used by the virtual machine, including
 * its stack and other execution-related structures. It should be called
 * when the virtual machine is no longer needed.
 */
void freeVM();

/**
 * @brief Interprets and executes a chunk of bytecode from source code.
 *
 * This function compiles the provided source code into bytecode and
 * then executes that bytecode in the virtual machine. It returns an
 * `InterpretResult` indicating whether the execution was successful
 * or if there were errors during compilation or runtime.
 *
 * @param source The source code to compile and execute.
 * @return An `InterpretResult` representing the outcome of the execution.
 */
InterpretResult interpret(const char* source);

/**
 * @brief Pushes a value onto the virtual machine's stack.
 *
 * This function pushes a `Value` onto the top of the stack, advancing
 * the `stackTop` pointer. If the stack exceeds its current capacity,
 * it dynamically grows to accommodate more values.
 *
 * @param value The value to push onto the stack.
 */
void push(Value value);

/**
 * @brief Pops a value off the virtual machine's stack.
 *
 * This function removes and returns the value from the top of the stack,
 * decrementing the `stackTop` pointer. The value is removed from the stack,
 * allowing space for new values to be pushed later.
 *
 * @return The value popped from the top of the stack.
 */
Value pop();

#endif